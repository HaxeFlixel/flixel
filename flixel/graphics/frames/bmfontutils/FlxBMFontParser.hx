package flixel.graphics.frames.bmfontutils;

import flixel.FlxG;
import flixel.graphics.frames.bmfontutils.BMFont.BMFontCharBlock;
import flixel.graphics.frames.bmfontutils.BMFont.BMFontCommonBlock;
import flixel.graphics.frames.bmfontutils.BMFont.BMFontInfoBlock;
import flixel.graphics.frames.bmfontutils.BMFont.BMFontKerningPair;
import flixel.graphics.frames.bmfontutils.BMFont.BMFontPageInfoBlock;
import flixel.system.FlxAssets.FlxAngelCodeAsset;
import haxe.io.Bytes;
import haxe.io.BytesBuffer;
import haxe.io.BytesInput;
import UnicodeString;

using StringTools;

/**
 * A class that can parse the font descriptor files generated by AngelCode's BMFont tool
 */
class FlxBMFontParser
{
	public static function parse(data:FlxAngelCodeAsset)
	{
		final angelCodeDataType = BMFontFileTypeHelper.guessType(data);
		return switch angelCodeDataType
		{
			case TEXT(text):
				BMFont.fromText(text);
			case XML(xml):
				BMFont.fromXml(xml);
			case BINARY(bytes):
				fromBinary(bytes);
		};
	}
	
	static function fromBinary(bytes:Bytes)
	{
		return new FlxBMFontBinaryParser(new BytesInput(bytes)).parse();
	}
}

@:access(flixel.graphics.frames.bmfontutils.BMFont)
class FlxBMFontBinaryParser
{
	var bytesInput:BytesInput;
	
	public static inline var BT_INFO:Int = 1;
	public static inline var BT_COMMON:Int = 2;
	public static inline var BT_PAGES:Int = 3;
	public static inline var BT_CHARS:Int = 4;
	public static inline var BT_KERNING_PAIRS:Int = 5;
	
	public function new(input:BytesInput)
	{
		bytesInput = input;
	}
	
	// @see https://www.angelcode.com/products/bmfont/doc/file_format.html#bin
	public function parse()
	{
		final fontInfo = new BMFont();
		final expectedBytes = [66, 77, 70]; // 'B', 'M', 'F'
		for (b in expectedBytes)
		{
			var testByte = bytesInput.readByte();
			if (testByte != b)
				throw 'Invalid binary .fnt file. Found $testByte, expected $b';
		}
		var version = bytesInput.readByte();
		if (version < 3)
		{
			FlxG.log.warn('The BMFont parser is made to work on files with version 3. Using earlier versions can cause issues!');
		}
		
		// parsing blocks
		while (bytesInput.position < bytesInput.length)
		{
			var blockId = bytesInput.readByte();
			switch blockId
			{
				case BT_INFO:
					fontInfo.info = parseInfoBlock();
				case BT_COMMON:
					fontInfo.common = parseCommonBlock();
				case BT_PAGES:
					fontInfo.pages = parsePagesBlock();
				case BT_CHARS:
					fontInfo.chars = parseCharsBlock();
				case BT_KERNING_PAIRS:
					fontInfo.kerningPairs = parseKerningPairs();
			}
		}
		return fontInfo;
	}
	
	function parseInfoBlock()
	{
		final blockSize = bytesInput.readInt32();
		final size = bytesInput.readInt16();
		final bitField = bytesInput.readByte();
		final fontInfo:BMFontInfoBlock = {
			size: size,
			smooth: (bitField & 0x80) != 0,
			unicode: (bitField & (0x80 >> 1)) != 0,
			italic: (bitField & (0x80 >> 2)) != 0,
			bold: (bitField & (0x80 >> 3)) != 0,
			fixedHeight: (bitField & (0x80 >> 4)) != 0,
			charSet: String.fromCharCode(bytesInput.readByte()),
			stretchH: bytesInput.readInt16(),
			aa: bytesInput.readByte(),
			paddingUp: bytesInput.readByte(),
			paddingRight: bytesInput.readByte(),
			paddingDown: bytesInput.readByte(),
			paddingLeft: bytesInput.readByte(),
			spacingHoriz: bytesInput.readByte(),
			spacingVert: bytesInput.readByte(),
			outline: bytesInput.readByte(),
			face: bytesInput.readString(blockSize - 14 - 1)
		};
		bytesInput.readByte(); // skip the null terminator of the string
		return fontInfo;
	}
	
	function parseCommonBlock()
	{
		var blockSize = bytesInput.readInt32();
		
		var lineHeight = bytesInput.readInt16();
		var base = bytesInput.readInt16();
		var scaleW = bytesInput.readInt16();
		var scaleH = bytesInput.readInt16();
		var pages = bytesInput.readInt16();
		var bitField = bytesInput.readByte();
		var isPacked = (bitField & 0x2) != 0;
		var commonBlock:BMFontCommonBlock = {
			lineHeight: lineHeight,
			base: base,
			scaleW: scaleW,
			scaleH: scaleH,
			pages: pages,
			isPacked: isPacked,
			alphaChnl: bytesInput.readByte(),
			redChnl: bytesInput.readByte(),
			greenChnl: bytesInput.readByte(),
			blueChnl: bytesInput.readByte(),
		};
		if (blockSize != 15)
			throw 'Invalid block size for common block. Expected 15 got $blockSize';
		return commonBlock;
	}
	
	function parsePagesBlock()
	{
		var blockSize = bytesInput.readInt32();
		var pagesBlock:Array<BMFontPageInfoBlock> = [];
		
		var bytesRead = 0;
		var i = 0;
		while (bytesRead < blockSize)
		{
			var bytesBuf = new BytesBuffer();
			var curByte = bytesInput.readByte();
			while (curByte != 0)
			{
				bytesBuf.addByte(curByte);
				curByte = bytesInput.readByte();
			}
			var pageName = bytesBuf.getBytes().toString();
			pagesBlock.push({id: i, file: pageName});
			bytesRead += pageName.length + 1;
			i++;
		}
		
		return pagesBlock;
	}
	
	function parseCharsBlock()
	{
		var blockSize = bytesInput.readInt32();
		var bytesRead = 0;
		var chars = [];
		while (bytesRead < blockSize)
		{
			var charInfo:BMFontCharBlock = {
				id: bytesInput.readInt32(),
				x: bytesInput.readInt16(),
				y: bytesInput.readInt16(),
				width: bytesInput.readInt16(),
				height: bytesInput.readInt16(),
				xoffset: bytesInput.readInt16(),
				yoffset: bytesInput.readInt16(),
				xadvance: bytesInput.readInt16(),
				page: bytesInput.readByte(),
				chnl: bytesInput.readByte(),
				letter: null
			};
			chars.push(charInfo);
			bytesRead += 20;
		}
		return chars;
	}
	
	function parseKerningPairs()
	{
		var blockSize = bytesInput.readInt32();
		var bytesRead = 0;
		var kerningPairs = [];
		while (bytesRead < blockSize)
		{
			var kerningPair:BMFontKerningPair = {
				first: bytesInput.readInt32(),
				second: bytesInput.readInt32(),
				amount: bytesInput.readInt16(),
			};
			kerningPairs.push(kerningPair);
			bytesRead += 10;
		}
		return kerningPairs;
	}
}

@:noCompletion
class BMFontTextAttributeParser
{
	public static var SPACE_REG = ~/ +/g;
	public static var QUOTES_REG = ~/^"(.+)"$/;
	public static function forEachAttribute(text:UnicodeString, callback:(key:String, value:UnicodeString)->Void)
	{
		for (s in SPACE_REG.split(text))
		{
			final split = s.split('=');
			final key = parseKey(split[0]);
			final value = parseValue(split[1]);
			callback(key, value);
		}
	}
	
	static inline function parseKey(text:String)
	{
		// return removeQuotes(text);// not needed
		return text;
	}
	
	static inline function parseValue(text:String)
	{
		return removeQuotes(text);
	}
	
	/**
	 * Removes surrounding quotes from text
	 */
	static inline function removeQuotes(text:String)
	{
		return QUOTES_REG.match(text) ? QUOTES_REG.matched(1) : text;
	}
}