package flixel.graphics.frames.bmfont;

import flixel.FlxG;
import flixel.graphics.frames.bmfont.BMFont;
import flixel.system.FlxAssets;
import haxe.io.Bytes;
import haxe.io.BytesBuffer;
import haxe.io.BytesInput;
import UnicodeString;

using StringTools;

/**
 * A class that can parse the font descriptor files generated by AngelCode's BMFont tool
 */
class FlxBMFontParser
{
	public static function parse(data:FlxAngelCodeAsset)
	{
		final angelCodeDataType = BMFontFileTypeHelper.guessType(data);
		return switch angelCodeDataType
		{
			case TEXT(text):
				BMFont.fromText(text);
			case XML(xml):
				BMFont.fromXml(xml);
			case BINARY(bytes):
				BMFont.fromBytes(bytes);
		};
	}
}

@:noCompletion
class BMFontTextAttributeParser
{
	public static var SPACE_REG = ~/ +/g;
	public static var QUOTES_REG = ~/^"(.+)"$/;
	public static function forEachAttribute(text:UnicodeString, callback:(key:String, value:UnicodeString)->Void)
	{
		for (s in SPACE_REG.split(text))
		{
			final split = s.split('=');
			final key = parseKey(split[0]);
			final value = parseValue(split[1]);
			callback(key, value);
		}
	}
	
	static inline function parseKey(text:String)
	{
		// return removeQuotes(text);// not needed
		return text;
	}
	
	static inline function parseValue(text:String)
	{
		return removeQuotes(text);
	}
	
	/**
	 * Removes surrounding quotes from text
	 */
	static inline function removeQuotes(text:String)
	{
		return QUOTES_REG.match(text) ? QUOTES_REG.matched(1) : text;
	}
}