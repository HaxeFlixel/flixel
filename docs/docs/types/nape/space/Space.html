<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/tr/html4/loose.dtd">
<html>
<head>
	<!-- Generated by chxdoc (build 752) on 2013-11-14 -->
	<title>Space (Haxe Application)</title>
	<meta name="date" content="2013-11-14"/>
	<meta name="keywords" content="nape.space.Space class"/>
	<link href="../../../stylesheet.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Space (Haxe Application)";
    }
}
</script>
<noscript></noscript>
</head>
<body onload="windowTitle();">
	<script type="text/javascript" language="javascript" src="../../../chxdoc.js"></script>
	<div class="type-frame" id="class-frame">
	<!-- ======== START OF class DATA ======== -->
	<h1 class="class">nape.space.Space</h1>
	<dl>
		<dt>type</dt>
		<dd>class</dd>
		<dt>metadata</dt>
		<dd><dl>
		<dt>:final</dt><dd></dd>
			</dl></dd>
	</dl>

	<div class="doc">
			<!-- Comment block -->
			 The heart of all Nape simulations.
				</div>
	<!-- ========= CONSTRUCTOR DETAIL ======== -->
	<div class="members-panel">
		<h2><a name="constructor_detail"></a>Constructor</h2>
		<div class="members">
			<div class="member">
				<div class="header">
					<a name="new()"></a>
	<span class="name">new</span>(?gravity : <a href="../../nape/geom/Vec2.html" class="type">nape.geom.Vec2</a>, ?broadphase : <a href="../../nape/space/Broadphase.html" class="type">Broadphase</a>)
				</div>
				<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>gravity</code> The gravity of this space. (default &#40;0,0&#41;)</dd>
									<dd><code>broadphase</code> The broadphase type to use. (default DYNAMIC_AABB_TREE)</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The constructed Space object.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If gravity is non-null, and has been disposed of.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Construct a new Space object.
</div>
		</div>
			</div>
		</div>
	</div>
	<!-- ============ FIELD field_detail =========== -->
	<div class="members-panel">
		<h2><a name="member_var_detail"></a>Instance Variables
		</h2>
		<div class="members">
			<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="arbiters"></a>
	<span class="name">arbiters</span>(accessor,null) : <a href="../../nape/dynamics/ArbiterList.html" class="type">nape.dynamics.ArbiterList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all active arbiters in Space.
      <br/><br/>
      This list is immutable.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bodies"></a>
	<span class="name">bodies</span>(accessor,null) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all Bodys directly placed in space.
      <br/><br/>
      This list is mutable, and adding an element to this list is one way of
      adding a Body to this Space equivalent to: <code>body.space = space</code>
      <br/><br/>
      This list is only those bodies directly placed in the space, any
      body that is a child of a Compound will not be in this list.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="broadphase"></a>
	<span class="name">broadphase</span>(accessor,null) : <a href="../../nape/space/Broadphase.html" class="type">Broadphase</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Broadphase type in use.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="compounds"></a>
	<span class="name">compounds</span>(accessor,null) : <a href="../../nape/phys/CompoundList.html" class="type">nape.phys.CompoundList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all Compounds directly placed in space.
      <br/><br/>
      This list is mutable, and adding an element to this list is one way of
      adding a Compound to this Space equivalent to: <code>compound.space = space</code>
      <br/><br/>
      This list is only those compounds directly placed in the space, any
      compound that is a child of another compound will not be in this list.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="constraints"></a>
	<span class="name">constraints</span>(accessor,null) : <a href="../../nape/constraint/ConstraintList.html" class="type">nape.constraint.ConstraintList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all Constraints directly placed in space.
      <br/><br/>
      This list is mutable, and adding an element to this list is one way of
      adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>
      <br/><br/>
      This list is only those bodies directly placed in the space, any
      constraint that is a child of a Compound will not be in this list.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="elapsedTime"></a>
	<span class="name">elapsedTime</span>(accessor,null) : <a href="../../Float.html" class="type">Float</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> The elapsed simulation time.
      <br/><br/>
      This is the total amount of 'time' that has elapsed in the Space simulation.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="gravity"></a>
	<span class="name">gravity</span>(accessor,accessor) : <a href="../../nape/geom/Vec2.html" class="type">nape.geom.Vec2</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Space gravity.
      <br/><br/>
      Units are of pixels/second/second</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="listeners"></a>
	<span class="name">listeners</span>(accessor,null) : <a href="../../nape/callbacks/ListenerList.html" class="type">nape.callbacks.ListenerList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all Listeners in space.
      <br/><br/>
      This list is mutable, and adding an element to this list is one way of
      adding a Listener to this Space equivalent to: <code>listener.space = space</code></div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="liveBodies"></a>
	<span class="name">liveBodies</span>(accessor,null) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all active dynamic Bodies in space.
      <br/><br/>
      This list contains all dynamic bodies that are awake regardless of their containment in a Compound.
      <br/><br/>
      This list is immutable.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="liveConstraints"></a>
	<span class="name">liveConstraints</span>(accessor,null) : <a href="../../nape/constraint/ConstraintList.html" class="type">nape.constraint.ConstraintList</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> List of all active Constraints in space.
      <br/><br/>
      This list contains all constraints regardless of their containment in a Compound.
      <br/><br/>
      This list is immutable.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="sortContacts"></a>
	<span class="name">sortContacts</span>(accessor,accessor) : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Flag controlling sorting of contact points.
      <br/><br/>
      If true, then collisions will be resolved in an order defined by their
      penetration depths. This can be shown to improve stability of the physics
      as well as making simulations more consistent regardless of which broadphase
      is used.
      <br/><br/>
      Having sorting enabled obviously incurs a cost, and you may consider
      disabling it if you are having issues with performance (Though things
      such as number of physics iterations will have much greater bearing on
      performance than this, especcialy since enabling this may permit you
      to use less iterations).
</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="timeStamp"></a>
	<span class="name">timeStamp</span>(accessor,null) : <a href="../../Int.html" class="type">Int</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> The time stamp of this Space object.
      <br/><br/>
      This is equal to the number of times that space.step(..) has been invoked.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="userData"></a>
	<span class="name">userData</span>(accessor,null) : <a href="../../Dynamic.html" class="type">Dynamic</a>&lt;<a href="../../Dynamic.html" class="type">Dynamic</a>&gt;
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Dynamic object for user to store additional data.
      <br/><br/>
      This object cannot be set, only its dynamically created
      properties may be set. In AS3 the type of this property is &#42
      <br/><br/>
      This object will be lazily constructed so that until accessed
      for the first time, will be null internally.
</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="world"></a>
	<span class="name">world</span>(accessor,null) : <a href="../../nape/phys/Body.html" class="type">nape.phys.Body</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Static, immutable Body for constraint purposes.
      <br/><br/>
      This is a completely static, uncollidable, uninteractable Body
      with no Shapes, that cannot be modified in any way.
      <br/><br/>
      Its purpose is to provide a means for attaching Constraints
      from one Body to the Space itself, for instance pinning a body
      against a static point in space.</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="worldAngularDrag"></a>
	<span class="name">worldAngularDrag</span>(accessor,accessor) : <a href="../../Float.html" class="type">Float</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Angular drag applied to all bodies in Space.
      <br/><br/>
      This represents the fraction of a body's angular velocity which will be
      removed per second. This value has no unit attached.
</div>
		</div>
				</div>
			</span>
					<span class="showVar">
				<div class="member">
					<div class="header">
		<h3>
			<a name="worldLinearDrag"></a>
	<span class="name">worldLinearDrag</span>(accessor,accessor) : <a href="../../Float.html" class="type">Float</a>
		</h3>
	</div>
					<div class="body">
		<!-- platforms -->
			<dl>
			</dl>
			<!-- meta -->
		<!-- Comment block -->
		<div class="comment"> Linear drag applied to all bodies in Space.
      <br/><br/>
      This represents the fraction of a body's linear velocity which will be
      removed per second. This value has no unit attached.
</div>
		</div>
				</div>
			</span>
				</div>
	</div>
	<!-- ============ METHOD DETAIL ========== -->
	<div class="members-panel">
		<h2><a name="method_detail"></a>Instance Methods
		</h2>
		<div class="members">
			<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bodiesInAABB()"></a>
	<span class="name">bodiesInAABB</span>(aabb : <a href="../../nape/geom/AABB.html" class="type">nape.geom.AABB</a>, ?containment : <a href="../../Bool.html" class="type">Bool</a>, ?strict : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>aabb</code> The bounding box to query bodies by,</dd>
									<dd><code>containment</code> If true, then only Bodies entirely contained (Rather than simply intersecting) will be considered. (default false)</dd>
									<dd><code>strict</code> If false, then the body's shape's bounding box will be used to classify the shapes of the body, instead of the Shape itself. (default true)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the shapes for given AABB.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If AABB is null, or is degenerate.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Bodies given an AABB.
      <br/><br/>
      If the filter argument is non-null, then only bodies with a shape
      classified as being part of the AABB, whose filter agrees to collide
      will be considered.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bodiesInBody()"></a>
	<span class="name">bodiesInBody</span>(body : <a href="../../nape/phys/Body.html" class="type">nape.phys.Body</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>body</code> The body to use in classifying other bodies.</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the bodies for given body.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If body is null.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If body has a shape that is a polygon, and that polygon is not 'valid'</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Bodies given a Body.
      <br/><br/>
      If the filter argument is non-null, then only bodies with a shape
      classified as being part of the input body, whose filter agrees to collide
      will be considered. The input body is considered a purely geometric
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bodiesInCircle()"></a>
	<span class="name">bodiesInCircle</span>(position : <a href="../../nape/geom/Vec2.html" class="type">nape.geom.Vec2</a>, radius : <a href="../../Float.html" class="type">Float</a>, ?containment : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>position</code> The position of the centre of the circle.</dd>
									<dd><code>radius</code> The radius of the circle.</dd>
									<dd><code>containment</code> If true, then only Bodies entirely contained (Rather than simply intersecting) will be considered. If a filter is supplied, only shapes that agree to collide will be used in this containment check. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the shapes for given circle.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If positions is null or disposed of.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If radius is not strictly positive.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Bodies given a circle.
      <br/><br/>
      If the filter argument is non-null, then only bodies with a shape
      classified as being part of the circle, whose filter agrees to collide
      will be considered.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bodiesInShape()"></a>
	<span class="name">bodiesInShape</span>(shape : <a href="../../nape/shape/Shape.html" class="type">nape.shape.Shape</a>, ?containment : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>shape</code> The shape to use in classifying other shapes.</dd>
									<dd><code>containment</code> If true, then only Bodies entirely contained (Rather than simply intersecting) will be considered. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the bodies for given shape.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If shape is null or not part of a body.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If shape is a polygon, and that polygon is not 'valid'</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Bodies given a shape.
      <br/><br/>
      If the filter argument is non-null, then only bodies with a shape
      classified as being part of the input shape, whose filter agrees to collide
      will be considered. The input shape is considered a purely geometric
      <br/><br/>
      The input shape must be part of a Body so as to be well defined.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bodiesUnderPoint()"></a>
	<span class="name">bodiesUnderPoint</span>(point : <a href="../../nape/geom/Vec2.html" class="type">nape.geom.Vec2</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>) : <a href="../../nape/phys/BodyList.html" class="type">nape.phys.BodyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>point</code> The point to evaluate bodies.</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the Bodies containing the given point.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If point is null or disposed of.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Bodies under a given Point.
      <br/><br/>
      If the filter argument is non-null, then only bodies with a shape containing
      the given point whose filter agrees to 'collide' will be considered.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="clear()"></a>
	<span class="name">clear</span>() : <a href="../../Void.html" class="type">Void</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
				<!-- method throws -->
				<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Clear the Space of all objects.
      <br/><br/>
      Things such as the elapsed simulation time, and time step will too be
      reset to 0.
      <br/><br/>
      Parameters such as gravity, and worldLinearDrag will be untouched by
      this operation.</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="convexCast()"></a>
	<span class="name">convexCast</span>(shape : <a href="../../nape/shape/Shape.html" class="type">nape.shape.Shape</a>, deltaTime : <a href="../../Float.html" class="type">Float</a>, ?liveSweep : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>) : <a href="../../Null.html" class="type">Null</a>&lt;<a href="../../nape/geom/ConvexResult.html" class="type">nape.geom.ConvexResult</a>&gt;
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>shape</code> The Shape to be cast through space. This shape must belong to a body whose velocity is used to define the sweep.</dd>
									<dd><code>deltaTime</code> The amount of time to sweep the shape forward.</dd>
									<dd><code>liveSweep</code> If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The soonest result (if any) of convex intersection.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If shape is null, or not part of a body.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If deltaTime is negative.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Perform a convex cast for soonest collision.
      <br/><br/>
      This method will return only the soonest collision result (if any), to find
      more than this, use the convexMultiCast method. The shape will not be
      swept further than the time delta provided.
      Shapes already intersecting
      the sweep shape at t = 0 are ignored.
      <br/><br/>
      If the filter argument is null, then all shapes will be collidable
      otherwise only those for whose filter agrees to 'collide'.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="convexMultiCast()"></a>
	<span class="name">convexMultiCast</span>(shape : <a href="../../nape/shape/Shape.html" class="type">nape.shape.Shape</a>, deltaTime : <a href="../../Float.html" class="type">Float</a>, ?liveSweep : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, output : <a href="../../nape/geom/ConvexResultList.html" class="type">nape.geom.ConvexResultList</a>) : <a href="../../nape/geom/ConvexResultList.html" class="type">nape.geom.ConvexResultList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>shape</code> The Shape to be cast through space. This shape must belong to a body whose velocity is used to define the sweep.</dd>
									<dd><code>deltaTime</code> The amount of time to sweep the shape forward.</dd>
									<dd><code>liveSweep</code> If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> A list to append results to instead of allocating a new one (default null)</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The collision results in time order.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If shape is null, or not part of a body.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If deltaTime is negative.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Perform a convex cast for all collisions in time order.
      <br/><br/>
      This method will return all collisions, or an empty list if there are none.
      The shape will not be
      swept further than the time delta provided. Shapes already intersecting
      the sweep shape at t = 0 are ignored.
      <br/><br/>
      If the filter argument is null, then all shapes will be collidable
      otherwise only those for whose filter agrees to 'collide'.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="interactionType()"></a>
	<span class="name">interactionType</span>(shape1 : <a href="../../nape/shape/Shape.html" class="type">nape.shape.Shape</a>, shape2 : <a href="../../nape/shape/Shape.html" class="type">nape.shape.Shape</a>) : <a href="../../Null.html" class="type">Null</a>&lt;<a href="../../nape/callbacks/InteractionType.html" class="type">nape.callbacks.InteractionType</a>&gt;
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>shape1</code> The first Shape to test.</dd>
									<dd><code>shape2</code> The second Shape to test.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The interaction type that will occur between these shapes, or null if no interaction will occur.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If either shape is null, or is not contained within a body.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine the interaction type that would occur between a pair of Shapes.
      <br/><br/>
      This function takes into account everything possible, and ignoring the
      callback system will tell you precisely the type of interaction (if any
      at all) which will occur between these Shapes.
      <br/><br/>
      This function can only work if the Shapes belong to a Body.
      <br/><br/>
      This function can only make use of any constraints 'ignore' property
      to determine if 'null' should be returned if the constraints being used
      are inside of a Space.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="rayCast()"></a>
	<span class="name">rayCast</span>(ray : <a href="../../nape/geom/Ray.html" class="type">nape.geom.Ray</a>, ?inner : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>) : <a href="../../Null.html" class="type">Null</a>&lt;<a href="../../nape/geom/RayResult.html" class="type">nape.geom.RayResult</a>&gt;
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>ray</code> The ray to cast through space.</dd>
									<dd><code>inner</code> If true then inner surfaces of shapes will also be intersected. otherwise only the outer surfaces. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The closest result (if any) of ray intersection.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If ray is null.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Perform a ray cast for closest result.
      <br/><br/>
      This method will return only the closest result (if any), to find more
      the first result, use the rayMultiCast method. The ray will not be
      cast beyond its maxDistance.
      <br/><br/>
      If the filter argument is null, then all shapes will be intersectable
      otherwise only those for whose filter agrees to 'collide'.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="rayMultiCast()"></a>
	<span class="name">rayMultiCast</span>(ray : <a href="../../nape/geom/Ray.html" class="type">nape.geom.Ray</a>, ?inner : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/geom/RayResultList.html" class="type">nape.geom.RayResultList</a>) : <a href="../../nape/geom/RayResultList.html" class="type">nape.geom.RayResultList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>ray</code> The ray to cast through space.</dd>
									<dd><code>inner</code> If true then inner surfaces of shapes will also be intersected. otherwise only the outer surfaces. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> A list to append results to instead of allocating a new one (default null)</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>All valid results of ray cast in distance order from closest to furthest.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If ray is null.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Perform a ray cast for all valid results.
      <br/><br/>
      This method will return all intersections (in distance order) of ray
      with shapes in the space up to the ray's maxDistance.
      <br/><br/>
      If the filter argument is null, then all shapes will be intersectable
      otherwise only those for whose filter agrees to 'collide'.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="shapesInAABB()"></a>
	<span class="name">shapesInAABB</span>(aabb : <a href="../../nape/geom/AABB.html" class="type">nape.geom.AABB</a>, ?containment : <a href="../../Bool.html" class="type">Bool</a>, ?strict : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>) : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>aabb</code> The bounding box to query shapes by,</dd>
									<dd><code>containment</code> If true, then only Shapes entirely contained (Rather than simply intersected) will be considered. (default false)</dd>
									<dd><code>strict</code> If false, then the Shape's bounding box will be used to classify the Shape, instead of the Shape itself. (default true)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the shapes for given AABB.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If AABB is null, or is degenerate.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Shapes given an AABB.
      <br/><br/>
      If the filter argument is non-null, then only shapes who's filter
      agrees to 'collide' will be considered.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="shapesInBody()"></a>
	<span class="name">shapesInBody</span>(body : <a href="../../nape/phys/Body.html" class="type">nape.phys.Body</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>) : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>body</code> The body to use in classifying other shapes.</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the shapes for given body.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If body is null.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If body has a shape that is a polygon, and that polygon is not 'valid'</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Shapes given a Body.
      <br/><br/>
      If the filter argument is non-null, then only shapes who's filter
      agrees to 'collide' will be considered. The input body's shape's own filters
      are never used in this method. The input body is considered a purely
      geometric object.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="shapesInCircle()"></a>
	<span class="name">shapesInCircle</span>(position : <a href="../../nape/geom/Vec2.html" class="type">nape.geom.Vec2</a>, radius : <a href="../../Float.html" class="type">Float</a>, ?containment : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>) : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>position</code> The position of the centre of the circle.</dd>
									<dd><code>radius</code> The radius of the circle.</dd>
									<dd><code>containment</code> If true, then only Shapes entirely contained (Rather than simply intersected) will be considered. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the shapes for given circle.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If positions is null or disposed of.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If radius is not strictly positive.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Shapes given a circle.
      <br/><br/>
      If the filter argument is non-null, then only shapes who's filter
      agrees to 'collide' will be considered.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="shapesInShape()"></a>
	<span class="name">shapesInShape</span>(shape : <a href="../../nape/shape/Shape.html" class="type">nape.shape.Shape</a>, ?containment : <a href="../../Bool.html" class="type">Bool</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>) : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>shape</code> The shape to use in classifying other shapes.</dd>
									<dd><code>containment</code> If true, then only Shapes entirely contained (Rather than simply intersected) will be considered. (default false)</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the shapes for given shape.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If shape is null or not part of a body.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If shape is a polygon, and that polygon is not 'valid'</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Shapes given another shape.
      <br/><br/>
      If the filter argument is non-null, then only shapes who's filter
      agrees to 'collide' will be considered. The input shape's own filter
      is never used in this method. The input shape is considered a purely
      geometric object.
      <br/><br/>
      The input shape must be part of a Body so as to be well defined.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="shapesUnderPoint()"></a>
	<span class="name">shapesUnderPoint</span>(point : <a href="../../nape/geom/Vec2.html" class="type">nape.geom.Vec2</a>, ?filter : <a href="../../nape/dynamics/InteractionFilter.html" class="type">nape.dynamics.InteractionFilter</a>, ?output : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>) : <a href="../../nape/shape/ShapeList.html" class="type">nape.shape.ShapeList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>point</code> The point to evaluate shapes.</dd>
									<dd><code>filter</code> Optional filter to pick and choose shapes, based on whether the filters agree to collide. (default null)</dd>
									<dd><code>output</code> Optional list to append results to instead of creating a new list (default null).</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of all the Shapes containing the given point.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If point is null or disposed of.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Evaluate all Shapes under a given Point.
      <br/><br/>
      If the filter argument is non-null, then only shapes who's filter
      agrees to 'collide' will be considered.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="step()"></a>
	<span class="name">step</span>(deltaTime : <a href="../../Float.html" class="type">Float</a>, ?velocityIterations : <a href="../../Int.html" class="type">Int</a>, ?positionIterations : <a href="../../Int.html" class="type">Int</a>) : <a href="../../Void.html" class="type">Void</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>deltaTime</code> The number of seconds to simulate. For 60fps physics you would use a value of 1/60.</dd>
									<dd><code>velocityIterations</code> The number of iterations to use in resolving errors in the velocities of objects. This is together with collision detection the most expensive phase of a simulation update, as well as the most important for stable results. (default 10)</dd>
									<dd><code>positionIterations</code> The number of iterations to use in resolving errors in the positions of objects. This is far more lightweight than velocity iterations, as well as being less important for the stability of results. (default 10)</dd>
											<!-- method return types comments -->
				<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If deltaTime is not strictly positive.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If either of the number of iterations is not strictly positive.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Step simulation forward in time.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="visitBodies()"></a>
	<span class="name">visitBodies</span>(lambda : <a href="../../nape/phys/Body.html" class="type">nape.phys.Body</a> -> <a href="../../Void.html" class="type">Void</a>) : <a href="../../Void.html" class="type">Void</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>lambda</code> The function to apply to each Body.</dd>
											<!-- method return types comments -->
				<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If lambda is null.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Apply given function to all bodies in space.
      <br/><br/>
      This method is a way to iterate over 'every' Body in the Space
      regardless of containment in a Compound.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="visitCompounds()"></a>
	<span class="name">visitCompounds</span>(lambda : <a href="../../nape/phys/Compound.html" class="type">nape.phys.Compound</a> -> <a href="../../Void.html" class="type">Void</a>) : <a href="../../Void.html" class="type">Void</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>lambda</code> The function to apply to each Compound.</dd>
											<!-- method return types comments -->
				<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If lambda is null.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Apply given function to all compounds in space.
      <br/><br/>
      This method is a way to iterate over 'every' Compound in the Space
      regardless of containment in another Compound.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="visitConstraints()"></a>
	<span class="name">visitConstraints</span>(lambda : <a href="../../nape/constraint/Constraint.html" class="type">nape.constraint.Constraint</a> -> <a href="../../Void.html" class="type">Void</a>) : <a href="../../Void.html" class="type">Void</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>lambda</code> The function to apply to each Constraint.</dd>
											<!-- method return types comments -->
				<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If lambda is null.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Apply given function to all constraints in space.
      <br/><br/>
      This method is a way to iterate over 'every' Constraint in the Space
      regardless of containment in a Compound.
</div>
		</div>
				</div>
			</span>
				</div>
	</div>
	</div>
<!-- ========= END OF class DATA ========= -->
	<div id="footer"></div>
</body>
</html>
