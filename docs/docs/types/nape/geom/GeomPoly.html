<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/tr/html4/loose.dtd">
<html>
<head>
	<!-- Generated by chxdoc (build 752) on 2013-11-14 -->
	<title>GeomPoly (Haxe Application)</title>
	<meta name="date" content="2013-11-14"/>
	<meta name="keywords" content="nape.geom.GeomPoly class"/>
	<link href="../../../stylesheet.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GeomPoly (Haxe Application)";
    }
}
</script>
<noscript></noscript>
</head>
<body onload="windowTitle();">
	<script type="text/javascript" language="javascript" src="../../../chxdoc.js"></script>
	<div class="type-frame" id="class-frame">
	<!-- ======== START OF class DATA ======== -->
	<h1 class="class">nape.geom.GeomPoly</h1>
	<dl>
		<dt>type</dt>
		<dd>class</dd>
		<dt>metadata</dt>
		<dd><dl>
		<dt>:final</dt><dd></dd>
			</dl></dd>
	</dl>

	<div class="doc">
			<!-- Comment block -->
			 Polygon class with various geometric methods
  <br/><br/>
  This class represents a general Polygon, rather than the Polygon class
  which is physics shape.
  <br/><br/>
  Internally this polygon is stored as a circularly linked list of special
  vertex types that are exposed via a Vec2 that is lazily constructed whenever
  necessary to the API.
				</div>
	<!-- ============ STATIC METHOD DETAIL ========== -->
	<div class="members-panel">
		<h2><a name="function_detail"></a>Static Methods</h2>
		<div class="members">
			<div class="member">
				<div class="header">
		<h3>
			<a name="get()"></a>
	<span class="name">get</span>(?vertices : <a href="../../Dynamic.html" class="type">Dynamic</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
				<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>vertices</code> Vertex data to initialise polygon, or null for empty polygon.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>New GeomPoly representing input vertex data, allocated from object pool.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If input data is not of an expected Type.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Allocate GeomPoly from object pool.
      <br/><br/>
      The vertices argument is typed Dynamic (* in AS3), and is permitted
      to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
      <br/><br/>
      The input will be used to initialise the vertices of the polygon with
      the head of the polygon pointing to the first vertex in input with vertices
      inserted in forward order.
</div>
		</div>
			</div>
				</div>
	</div>
	<!-- ========= CONSTRUCTOR DETAIL ======== -->
	<div class="members-panel">
		<h2><a name="constructor_detail"></a>Constructor</h2>
		<div class="members">
			<div class="member">
				<div class="header">
					<a name="new()"></a>
	<span class="name">new</span>(?vertices : <a href="../../Dynamic.html" class="type">Dynamic</a>)
				</div>
				<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>vertices</code> Vertex data to initialise polygon, or null for empty polygon.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>New GeomPoly representing input vertex data.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If input data is not of an expected Type.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Create a new GeomPoly polygon.
      <br/><br/>
      The vertices argument is typed Dynamic (* in AS3), and is permitted
      to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
      <br/><br/>
      The input will be used to initialise the vertices of the polygon with
      the head of the polygon pointing to the first vertex in input with vertices
      inserted in forward order.
      <br/><br/>
      You should use the static 'get' method in preference to make use of object pool.
</div>
		</div>
			</div>
		</div>
	</div>
	<!-- ============ METHOD DETAIL ========== -->
	<div class="members-panel">
		<h2><a name="method_detail"></a>Instance Methods
		</h2>
		<div class="members">
			<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="area()"></a>
	<span class="name">area</span>() : <a href="../../Float.html" class="type">Float</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The area of the polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Compute area of weakly-simple polygon.
      <br/><br/>
      For complex polygons, this function will return an underestimate
      to the true area.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="backwardsIterator()"></a>
		<span class="inline">inline</span>
		<span class="name">backwardsIterator</span>() : <a href="../../nape/geom/GeomVertexIterator.html" class="type">GeomVertexIterator</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Haxe iterator over the vertices of the polygon. Iterating in a backwards direction.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Haxe iterator over vertices of polygon.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bottom()"></a>
	<span class="name">bottom</span>() : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Vec2 representing the bottom most vertex.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Find bottom most vertex of polygon.
      <br/><br/>
      If there is more than one such vertex then the result is indeterminate.
      <br/><br/>
      The Vec2 returned is intrinsically tied to the inner vertex like that
      returned by current(). This method will not alter the current vertex.
      This Vec2 is not able to be disposed of.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="bounds()"></a>
	<span class="name">bounds</span>() : <a href="../../nape/geom/AABB.html" class="type">AABB</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A new AABB representing bounds of polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine bounds of polygon.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="clear()"></a>
	<span class="name">clear</span>() : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Clear all vertices from polygon.
      <br/><br/>
      All of the vertices will be released to the global object pool.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="contains()"></a>
	<span class="name">contains</span>(point : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>) : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>point</code> The point to test for containment.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if point is contained in the polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If point is null or has been disposed.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if point is contained in polygon.
      <br/><br/>
      Polygon containment is performed with a ray cast through polygon
      from the vertex and counting the number of intersections. In this
      way containment will be defined for self-intersecting polygons based
      on how such a polygon would be rendered with areas of self-intersection
      treat as being 'outside' the polygon.
      <br/><br/>
      This algorithm operates in O(n) time.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="convexDecomposition()"></a>
	<span class="name">convexDecomposition</span>(?delaunay : <a href="../../Bool.html" class="type">Bool</a>, ?output : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>) : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>delaunay</code> This algorithm first performs a triangulation, if this field is true, then this triangulation will be made delaunay and may produce better convex polygons resultanly (default false).</dd>
									<dd><code>output</code> If supplied, polygons will be appended to this list via 'add' instead of a new list being constructed.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Nape list of GeomPoly's defining the decomposition.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is degenerate.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Produce a decomposition of weakly-simple polygon into convex components.
      <br/><br/>
      This algorithm 'should' be 100% robust and has been well test on for
      example, the output of the Marching Squars utility which produces many
      degenerate cases of weakly-simple polygons that have not yet broken this
      algorithm!.
      <br/><br/>
      This algorithm operates in O(n.log(n)) time and will produce no more than
      4 times the number of convex poylgons in a minimal decomposition in the
      worst case scenario.
      <br/><br/>
      Vertices may be stripped from the polygon that are found to not be
      necessary as part of making this algorithm robust.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="copy()"></a>
	<span class="name">copy</span>() : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The new GeomPoly representing the copy.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Copy this polygon.
      <br/><br/>
      The copy will have its vertices in the same order as 'this' polygon.
      It will also have its current vertex at head, as the same vertex
      this polygon has.
      <br/><br/>
      This polygon will not be modified in any way.
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly2 = poly.copy();

      poly2 := -> A' <-> B' <-> C' <-> D' <-> E' <-
                       (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="current()"></a>
		<span class="inline">inline</span>
		<span class="name">current</span>() : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Vec2 representing the current vertex of polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Current vertex at head of polygon.
      <br/><br/>
      The current vertex will not be changed by this access.
      <br/><br/>
      This function returns a Vec2 which will be intrinsically tied
      to the values of the internal vertex so that modifications to
      this Vec2 will be reflected in the vertex of the polygon.
      <br/><br/>
      If invoked again with the head of the polygon pointing to the
      same vertex, then the same Vec2 will be returned; this Vec2 is
      not able to be disposed of.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="cut()"></a>
	<span class="name">cut</span>(start : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>, end : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>, ?boundedStart : <a href="../../Bool.html" class="type">Bool</a>, ?boundedEnd : <a href="../../Bool.html" class="type">Bool</a>, ?output : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>) : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>start</code> The start point for line segment</dd>
									<dd><code>end</code> The end point for line segment.</dd>
									<dd><code>boundedStart</code> If true, then the cut will not extend beyond the start of the line segment. (default false)</dd>
									<dd><code>boundedEnd</code> If true, then the cut will not extend beyond the end of the line segment. (default false)</dd>
									<dd><code>output</code> A GeomPolyList to append results to if supplied, otherwise a new list is created (default null)</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of GeomPoly representing the result of the cut.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is not simple.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If start or end Vec2 are null or disposed of.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Cut simple polygon with line.
      <br/><br/>
      The result of this operation will be a list of new GeomPoly representing
      the connected regions of the polygon after an imaginary cut is made.
      <pre>
      (Result of cut assuming
       boundedStart = true)       _
        /&#92;    _             /&#92;   / &#92;
       /  &#92;  / &#92;           /  &#92; '---'
      / o--&#92;/---&#92;-->  =>  /    &#92;,---,
      &#92;_________/         &#92;_________/
      </pre>
      This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).
      For convex polygons, this algorithm runs in guaranteed O(n) time.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="dispose()"></a>
	<span class="name">dispose</span>() : <a href="../../Void.html" class="type">Void</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
				<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has already been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Release this GeomPoly to global object pool.
      <br/><br/>
      Once disposed this GeomPoly will be accessible to Nape internals for re-allocation
      and should not be touched (Good practice would be to set any references to this
      GeomPoly to null to help ensure this).
      <br/><br/>
      In debug mode, should you attempt to access this GeomPoly after disposal
      and the GeomPoly is still in the object pool, you will be given an Error.
      The object pool operates on a First-In-Last-Out principal in debug mode to help
      catch these sort of errors.</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="empty()"></a>
		<span class="inline">inline</span>
		<span class="name">empty</span>() : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if polygon is empty.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if polygon is empty.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="erase()"></a>
	<span class="name">erase</span>(count : <a href="../../Int.html" class="type">Int</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>count</code> The number of vertices to erase, with sign indicating the direction for erasing.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Erase count number of elements
      <br/><br/>
      For positive values of count, this is equivalent to successive
      unshift operations.
      <br/><br/>
      For negative values of count, this is equivalent to successive
      pop operations.
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-> F <-> G <-
                     (head)

      poly.erase(2);

      poly := -> A <-> D <-> E <-> F <-> G <-
                     (head)

      poly.erase(-3);

      poly := -> E <-> F <-
                     (head)
      </pre>
      In this case that the specified number of elements to erase is
      greater than the size of the polygon, the method will simply
      terminate with the polygon being empty.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="forwardIterator()"></a>
		<span class="inline">inline</span>
		<span class="name">forwardIterator</span>() : <a href="../../nape/geom/GeomVertexIterator.html" class="type">GeomVertexIterator</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Haxe iterator over the vertices of the polygon. Iterating in a forward direction.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Haxe iterator over vertices of polygon.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="inflate()"></a>
	<span class="name">inflate</span>(inflation : <a href="../../Float.html" class="type">Float</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>inflation</code> The number of pixels to inflate polygon by. To deflate use a negative value.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The inflated polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Inflate/Deflate polygon.
      <br/><br/>
      This algorithm does not attempt to deal with any self-intersections which may
      result from the process. Gaps are joined with a miter joint.
      <br/><br/>
      This algorithm will work for self-intersecting polygons, though the results
      may not be what you expect; some parts will be inflated, and some deflated
      depending on the local winding. You should probably avoid using this on
      self-intersecting polygons.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="isClockwise()"></a>
		<span class="inline">inline</span>
		<span class="name">isClockwise</span>() : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if polygon is clockwise wound.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if polygon is clockwise wound.
      <br/><br/>
      This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="isConvex()"></a>
	<span class="name">isConvex</span>() : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if polygon is found to be convex.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if weakly-simple polygon is convex.
      <br/><br/>
      This algorithm assumes that the polygon is weakly-simple. Otherwise it may
      fail (It is very easy to construct a self intersecting polygon which
      will return True for isConvex()).
      <br/><br/>
      You may wish to instead use <code>isSimple() && isConvex()</code> if
      you cannot be sure of the polygon being simple, noting that this will
      of course return false in the case of a weakly-simple polygon.
      <pre>
       _____
      |     |
      |     |  <-- convex
      |____/
       __
      |  &#92;___
      |     /  <-- concave
      |____/
      </pre>
      This algorithm operates in O(n) time.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="isDegenerate()"></a>
		<span class="inline">inline</span>
		<span class="name">isDegenerate</span>() : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if polygon is degenerate.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if weakly-simple polygon is degenerate.
      <br/><br/>
      Degeneracy is determined by having a zero area, if polygon is complex,
      then this function may report degeneracy erroneously.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="isMonotone()"></a>
		<span class="inline">inline</span>
		<span class="name">isMonotone</span>() : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if polygon is y-monotone.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if polygon is y-monotone.
      <br/><br/>
      To be classed as y-monotone, the polygon must be such that any horizontal
      line intersects the polygon in at most 2 intersections.
      <pre>
       ___
      |   |
      |   |  <-- y-monotone
      |___|

      |&#92;
      | &#92;/|  <-- not y-monotone, offending vertex at bottom of the V.
      |___|
      </pre>
      This algorithm operates in O(n) time.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="isSimple()"></a>
		<span class="inline">inline</span>
		<span class="name">isSimple</span>() : <a href="../../Bool.html" class="type">Bool</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>True if polygon is strictly simple.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine if polygon is strictly simple.
      <br/><br/>
      By strict simplicity, we refer to not permitting 'glancing'
      self intersections (where boundary of polygon 'touches' but does not
      pass through another area of the polygon's boundary). This property
      is instead referred to as being 'weakly simple' for which there is no
      easy test!
      <pre>
       _______
      |   __  |  <-- strictly simple polygon.
      |   &#92; &#92;_|
       &#92;__/
       _______
      |   |   |
      |  /_&#92;  | <-- weakly simple polygon.
       &#92;_____/
       ____
      | __/
       X_  __   <-- complex polygon.
      |  &#92;/  &#92;
      &#92;__/&#92;__|
      </pre>
      This algorithm operates in O(n.log(n)) time.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="iterator()"></a>
		<span class="inline">inline</span>
		<span class="name">iterator</span>() : <a href="../../nape/geom/GeomVertexIterator.html" class="type">GeomVertexIterator</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Haxe iterator over the vertices of the polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Haxe iterator over vertices of polygon.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="left()"></a>
	<span class="name">left</span>() : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Vec2 representing the left most vertex.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Find left most vertex of polygon.
      <br/><br/>
      If there is more than one such vertex then the result is indeterminate.
      <br/><br/>
      The Vec2 returned is intrinsically tied to the inner vertex like that
      returned by current(). This method will not alter the current vertex.
      This Vec2 is not able to be disposed of.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="monotoneDecomposition()"></a>
	<span class="name">monotoneDecomposition</span>(?output : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>) : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>output</code> If supplied, polygons will be appended to this list via 'add' instead of a new list being constructed.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Nape list of GeomPoly's defining the decomposition.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is degenerate.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Produce a decomposition of weakly-simple polygon into monotone components.
      <br/><br/>
      This algorithm 'should' be 100% robust and has been well tested on for
      example, the output of the Marching Squares utility which produces many
      degenerate cases of weakly-simple polygons that have not yet broken this
      algorithm!.
      <br/><br/>
      This algorithm operates in O(n.log(n)) time and may strip vertices from
      the polygon in degenerate cases where vertex is not needed to define the
      polygon.
      <br/><br/>
      This algorithm is an improved version of the one presented in: Mark de
      Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.
      Computational Geometry: Algorithms and Applications. Springer-Verlag,
      Berlin, 1997.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="pop()"></a>
	<span class="name">pop</span>() : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Pop vertex from polygon.
      <br/><br/>
      Pop the current vertex at head of polygon, retreating the 'current'
      vertex to point to the previous vertex in polygon. This inner vertex
      will be released to the global object pool.
      <br/><br/>
      In this way a pop which follows a push will act to reset the push.
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly.pop();

      poly := -> A <-> C <-> D <-> E <-
               (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="push()"></a>
	<span class="name">push</span>(vertex : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>vertex</code> The Vec2 to be used in initialising the inner vertex.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If Vec2 is null, or has been disposed.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Push vertex to polygon.
      <br/><br/>
      A vertex will be allocated from a global object pool, and initialised
      with the values of the given Vec2.
      <br/><br/>
      This vertex will be inserted after the current head, and the head
      advanced to the newly inserted vertex, in this way successive pushes
      will insert elements in order.
      <br/><br/>
      Note that the Vec2 supplied as argument is only used to initialise the
      inner Vertex.
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly.push(X);

      poly := -> A <-> B <-> X <-> C <-> D <-> E <-
                           (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="right()"></a>
	<span class="name">right</span>() : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Vec2 representing the right most vertex.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Find right most vertex of polygon.
      <br/><br/>
      If there is more than one such vertex then the result is indeterminate.
      <br/><br/>
      The Vec2 returned is intrinsically tied to the inner vertex like that
      returned by current(). This method will not alter the current vertex.
      This Vec2 is not able to be disposed of.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="shift()"></a>
	<span class="name">shift</span>() : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Shift vertex from polygon.
      <br/><br/>
      Shift the current vertex at head of polygon, advancing the 'current'
      vertex to point to the next vertex in polygon. This inner vertex
      will be released to the global object pool.
      <br/><br/>
      In this way a shift which follows an unshift will act to reset the
      unshift operation.
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly.shift();

      poly := -> A <-> C <-> D <-> E <-
                     (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="simpleDecomposition()"></a>
	<span class="name">simpleDecomposition</span>(?output : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>) : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>output</code> If supplied, polygons will be appended to this list via 'add' instead of a new list being constructed.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Nape list of GeomPoly's representing the decomposition.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is degenerate.</dd>
									<dd><a href="../../#.html"><code>#</code></a> Any other error may be thrown if algorithm has failed, even in release builds!</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Produce a decomposition of complex polygon into simple components.
      <br/><br/>
      WARNING: This method is 'not' 100% robust. It may fail!
      <br/><br/>
      Produce a decomposition of a self intersecting, complex polygon into
      a set of weakly-simple components.
      <br/><br/>
      This algorithm operates in O(n.log(n)) time and is based on the
      Bentley-Ottmann algorithm.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="simplify()"></a>
	<span class="name">simplify</span>(epsilon : <a href="../../Float.html" class="type">Float</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>epsilon</code> The distance from polygon at which vertices are ignored.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A new GeomPoly representing the result of the simplification.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If epsilon is <= 0.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Simplify polygon.
      <br/><br/>
      Simplification is performed with an implementation of the Ramer-Douglas-Peucker
      algorithm. The output polygon is formed via subset of the vertices in
      the input polygon such that any discarded vertex is at most 'epsilon' pixels
      away from the local output polygon.
      <br/><br/>
      This algorithm works on both simple and complex polygons, but please note
      that this algorithm makes no guarantees on a simple polygon remaining simple
      after simplification. This should not generally be a problem unless the epsilon
      value is large with respect to the size of the features on the polygon.
      <br/><br/>
      Many of the geometric algorithms will mark vertices as important, such that
      they will be guaranteed to exist after simplification (Such as preventing
      gaps from opening up in marching squares when simplifying output polygons).
      <br/><br/>
      The average runtime of this algorithm is O(n.log(n)). This algorithm is
      not stable in the sense that adding a new vertex to the polygon may drastically
      change the result of simplifying the polygon.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="size()"></a>
	<span class="name">size</span>() : <a href="../../Int.html" class="type">Int</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The number of vertices.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Determine number of vertices in polygon
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="skipBackwards()"></a>
		<span class="inline">inline</span>
		<span class="name">skipBackwards</span>(times : <a href="../../Int.html" class="type">Int</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Advance head of polygon backwards.
      <br/><br/>
      The current head of polygon will be moved backwards
      the given number of times, with a negative value
      being equivalent to performing a forwards advance.
      <br/><br/>
      <code>poly.skip_backwards(times)</code> is equivalent to
      <code>poly.skip_forwards(-times)</code>
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly.skipBackwards(2);

      poly := -> A <-> B <-> C <-> D <-> E <-
                                       (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="skipForward()"></a>
	<span class="name">skipForward</span>(times : <a href="../../Int.html" class="type">Int</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Advance head of polygon forward.
      <br/><br/>
      The current head of polygon will be moved forwards
      the given number of times, with a negative value
      being equivalent to performing a backwards advance.
      <br/><br/>
      <code>poly.skip_forwards(times)</code> is equivalent to
      <code>poly.skip_backwards(-times)</code>
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly.skipForwards(2);

      poly := -> A <-> B <-> C <-> D <-> E <-
                                 (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="top()"></a>
	<span class="name">top</span>() : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Vec2 representing the top most vertex.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is empty.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Find top most vertex of polygon.
      <br/><br/>
      If there is more than one such vertex then the result is indeterminate.
      <br/><br/>
      The Vec2 returned is intrinsically tied to the inner vertex like that
      returned by current(). This method will not alter the current vertex.
      This Vec2 is not able to be disposed of.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="transform()"></a>
	<span class="name">transform</span>(matrix : <a href="../../nape/geom/Mat23.html" class="type">Mat23</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>matrix</code> The matrix to transform polygon by.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If matrix is null.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Transform polygon by given matrix.
      <br/><br/>
      Any transformation (not just equiorthogonal ones) are permitted, though
      a transformation that causes polygon to be come degenerate is a bit
      pointless.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="triangularDecomposition()"></a>
	<span class="name">triangularDecomposition</span>(?delaunay : <a href="../../Bool.html" class="type">Bool</a>, ?output : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>) : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>delaunay</code> If true, then an O(n^2) pass will be made to mutate the original triangulation to push it into a delanuay triangulation. (default false)</dd>
									<dd><code>output</code> If supplied, polygons will be appended to this list via 'add' instead of a new list being constructed.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A Nape list of GeomPoly's defining the decomposition.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If polygon is degenerate.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Produce a decomposition of weakly-simple polygon into triangles.
      <br/><br/>
      This algorithm 'should' be 100% robust and has been well test on for
      example, the output of the Marching Squars utility which produces many
      degenerate cases of weakly-simple polygons that have not yet broken this
      algorithm!.
      <br/><br/>
      This algorithm operates in O(n.log(n)) time.
      <br/><br/>
      Vertices may be stripped from the polygon that are found to not be
      necessary as part of making this algorithm robust.
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="unshift()"></a>
	<span class="name">unshift</span>(vertex : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>) : <a href="../../nape/geom/GeomPoly.html" class="type">GeomPoly</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>vertex</code> The Vec2 to be used in initialising the inner vertex.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A reference to this polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If Vec2 is null, or has been disposed.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Unshift vertex to polygon.
      <br/><br/>
      A vertex will be allocated from a global object pool, and initialised
      with the values of the given Vec2.
      <br/><br/>
      This vertex will be inserted before the current head, and the head
      retreated to the newly inserted vertex, in this way successive unshifts
      will insert elements in the expected reverse order.
      <br/><br/>
      Note that the Vec2 supplied as argument is only used to initialise the
      inner Vertex.
      <pre>
      poly := -> A <-> B <-> C <-> D <-> E <-
                     (head)

      poly.unshift(X);

      poly := -> A <-> X <-> B <-> C <-> D <-> E <-
                     (head)
      </pre>
</div>
		</div>
				</div>
			</span>
					<span class="showMethod">
				<div class="member">
					<div class="header">
		<h3>
			<a name="winding()"></a>
	<span class="name">winding</span>() : <a href="../../nape/geom/Winding.html" class="type">Winding</a>
		</h3>
	</div>
					<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
				<!-- method return types comments -->
					<dt>returns</dt>
					<dd>The winding of the polygon.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If this GeomPoly has been disposed.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Compute the winding order for this polygon.
      <br/><br/>
      The winding order can be conceptualised by thinking of an analog
      clock face, if your polygon is the numbers on the clock then a
      clockwise winding would have your polygon's vertices in numerical
      order.
      <br/><br/>
      In the case of a non-simple polygon with self intersections then the
      winding order is decided by how 'much' of the polygon is locally
      clockwise wound, and how much is locally anti-clockwise wound.
      <br/>
      (Think of a figure 8 style polygon where one loop is larger than the
      other. This larger loop will dictate the winding of the polygon.)
      <br/><br/>
      If no winding can be computed, then <code>Winding.UNDEFINED</code>
      will be returned.
</div>
		</div>
				</div>
			</span>
				</div>
	</div>
	</div>
<!-- ========= END OF class DATA ========= -->
	<div id="footer"></div>
</body>
</html>
