<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/tr/html4/loose.dtd">
<html>
<head>
	<!-- Generated by chxdoc (build 752) on 2013-11-14 -->
	<title>MarchingSquares (Haxe Application)</title>
	<meta name="date" content="2013-11-14"/>
	<meta name="keywords" content="nape.geom.MarchingSquares class"/>
	<link href="../../../stylesheet.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MarchingSquares (Haxe Application)";
    }
}
</script>
<noscript></noscript>
</head>
<body onload="windowTitle();">
	<script type="text/javascript" language="javascript" src="../../../chxdoc.js"></script>
	<div class="type-frame" id="class-frame">
	<!-- ======== START OF class DATA ======== -->
	<h1 class="class">nape.geom.MarchingSquares</h1>
	<dl>
		<dt>type</dt>
		<dd>class</dd>
		<dt>metadata</dt>
		<dd><dl>
		<dt>:final</dt><dd></dd>
			</dl></dd>
	</dl>

	<div class="doc">
			<!-- Comment block -->
			 Iso-surface extraction into polygons.
  <br/><br/>
  This class, with only one static method provides an interface to
  an algorithm which will, when given a function mapping each point
  in a given AABB to a scalar value extract approximated polygons
  which represent the region of the AABB where the function returns
  a negative value.
  <br/><br/>
  This function could be a mathematical function like the equation of
  a circle: <code> function (x, y) return (x*x + y*y) - r*r </code>
  <br/>
  Or something more practical like the biased alpha value interpolated
  from a Bitmap:
  <pre>
  function (x, y) {
     var ix = if (x < 0) 0 else if (x >= bitmap.width - 1) bitmap.width - 2 else Std.int(x);
     var iy = if (y < 0) 0 else if (y >= bitmap.height - 1) bitmap.height - 2 else Std.int(y);
     var fx = x - ix;
     var fy = y - iy;
     var gx = 1 - fx;
     var gy = 1 - fy;

     var a00 = bitmap.getPixel32(ix, iy) >>> 24;
     var a01 = bitmap.getPixel32(ix, iy + 1) >>> 24;
     var a10 = bitmap.getPixel32(ix + 1, iy) >>> 24;
     var a11 = bitmap.getPixel32(ix + 1, iy + 1) >>> 24;

     return 0x80 - (gx*gy*a00 + fx*gy*a10 + gx*fy*a01 + fx*fy*a11);
  }
  </pre>
  For 'flash', we must wrap this in an IsoFunction interface to be used
  by MarchingSquares for performance reasons:
  <pre>
  class BitmapIsoFunction implements nape.geom.IsoFunction {
      public function iso(x:Float, y:Float):Float {
          ...
      }
  }
  </pre>
  This function is converted into a set of polygons by sampling along regular
  grid points, and then recursively interpolating along cell edges based on
  the function provided to find the point in space along that edge where the
  function is approximately 0.
  <br/><br/>
  From this we generate polygons in each grid cell, which are then by default
  combined into larger, weakly simply polygons suitable for use in the
  decomposition routines of GeomPoly like convexDecomposition!
  <br/><br/>
  The runtime of the algorithm is O(N+K) for N number of cells and K number
  of output vertices (A final pass is made to remove unnecessary vertices).
				</div>
	<!-- ============ STATIC METHOD DETAIL ========== -->
	<div class="members-panel">
		<h2><a name="function_detail"></a>Static Methods</h2>
		<div class="members">
			<div class="member">
				<div class="header">
		<h3>
			<a name="run()"></a>
	<span class="name">run</span>(iso : <a href="../../nape/geom/IsoFunctionDef.html" class="type">IsoFunctionDef</a>, bounds : <a href="../../nape/geom/AABB.html" class="type">AABB</a>, cellsize : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>, ?quality : <a href="../../Int.html" class="type">Int</a>, ?subgrid : <a href="../../nape/geom/Vec2.html" class="type">Vec2</a>, ?combine : <a href="../../Bool.html" class="type">Bool</a>, ?output : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>) : <a href="../../nape/geom/GeomPolyList.html" class="type">GeomPolyList</a>
		</h3>
	</div>
				<div class="body">
			<dl>
				<!-- deprecated -->
				<!-- type params -->
				<!-- method call parameters -->
					<dt>parameters</dt>
					<dd><code>iso</code> The iso-function defining the regions where polygons should be extracted, a negative return indicates a region to be extracted. This function need not be continuous, but if it is continuous then more accurate results will be given for the same input parameters.</dd>
									<dd><code>bounds</code> The AABB representing the region of space to be converted. The arguments to the iso-function will be in the same region.</dd>
									<dd><code>cellsize</code> The dimensions of each cell used individual polygon extraction. Smaller cells will give more accurate results at a greater cost permitting smaller features to be extracted.</dd>
									<dd><code>quality</code> This is the number of recursive interpolations which will be performed along cell edges. If the iso-function is not continuous, then this value should be increased to get better accuracy. (default 2)</dd>
									<dd><code>subgrid</code> When supplied, the region of space will be first subdivided into cells with these given dimensions, and each cell treated as a seperate invocation of this method, this value should obviously be greater than cellsize or it would be a bit pointless. (default null)</dd>
									<dd><code>combine</code> When True, the polygons generated in each cell of the grid will be combined into the largest possible weakly-simple polygons representing the same area. These polygons will always be suitable for decomposition in Nape. (default true)</dd>
									<dd><code>output</code> When supplied, GeomPoly will be inserted into the list (via add) instead of creating a new GeomPolyList object.</dd>
											<!-- method return types comments -->
					<dt>returns</dt>
					<dd>A list of GeomPoly representing the results of the extraction.</dd>
											<!-- method throws -->
					<dt>throws</dt>
					<dd><a href="../../#.html"><code>#</code></a> If iso, bounds or cellsize argument is null.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If cellsize is disposed, or its components have 0, or negative values.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If quality is less than 0.</dd>
									<dd><a href="../../#.html"><code>#</code></a> If subgrid is not null, but is disposed or has zero or negative component values.</dd>
											<!-- requires -->
				<!-- see -->
				<!-- todo -->
				<!-- authors -->
				<!-- meta -->
		
			<!-- platforms -->
					</dl>
			<!-- Comment block -->
		<div class="comment"> Execute marching squares algorithm over region of space.
      <br/><br/>
      We can, optionally provide a subgrid argument which, when non null
      will invoke this algorithm seperately on each subgrid cell of the region
      in space, instead of on the entire region at once. This can be very useful
      as shown in the DestructibleTerrain demo where regions of a terrain are
      recomputed with marching squares without needing to regenerate the whole
      of the terrain.
</div>
		</div>
			</div>
				</div>
	</div>
	</div>
<!-- ========= END OF class DATA ========= -->
	<div id="footer"></div>
</body>
</html>
